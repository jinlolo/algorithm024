# 学习笔记

## 深度和广度优先搜索算法

深度优先搜索算法和广度优先搜索算法就是作用于图这种数据结构的搜索算法，图上的搜索算法，就是从图中的一个顶点出发，到另一个顶点的路径。图有两种存储方法，邻接矩阵和邻接表，在这里我们用邻接表来存储图，并以无向图作为例子，但这两种算法也同样都可以应用在有向图中。

### 深度优先搜索 (DFS)

```
def dfs(node):
    if node in visited:
    return;
    visited.add(node);

    dfs(node.left);
    dfs(node.right);
```

上述是 dfs 的代码模板 ;
dfs 首先是在 visited 数组中判断节点是否存在,存在的情况 ， 需要 return 出去; 不存在的情况，需要使用递归;

### 广度优先搜索（BFS）

一种地毯式层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。

BFS 的代码模板是:

```
// 使用队列进行实现;
const bfs = (root) => {
    let result = [];
    let queue = [root];

    while(queue.length > 0) {
        let level = [];
        let n = queue.length;
        for (let i = 0 ;i < n;i++){
            let node = queue.pop();
            level.push(node.val);
        }
        if(node.left) queue.unshift(node.left)
        if(node.right) queue.unshift(node.right)
    }

    result.push(level);
    return result;
}
```

## 贪心算法

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。

贪心算法一般按如下步骤进行：

1. 建立数学模型来描述问题；
2. 把求解的问题分成若干个子问题；
3. 对每个子问题求解，得到子问题的局部最优解；
4. 把子问题的解局部最优解合成原来解问题的一个解。

贪心算法可解决的问题通常大部分都有如下的特性：

1. 有一个以最优方式来解决的问题。为了构造问题的解决方案，有一个候选的对象的集合：比如不同面值的硬币；
2. 随着算法的进行，将积累起其他两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象；
3. 有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优；
4. 还有一个函数检查是否一个候选对象的集合是可行的，即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性；
5. 选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解；
6. 最后，目标函数给出解的值。

## 二分查找

二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0

二分查找算法的原理如下：

1. 如果待查序列为空，那么就返回-1，并退出算法；这表示查找不到目标元素。
2. 如果待查序列不为空，则将它的中间元素与要查找的目标元素进行匹配，看它们是否相等。
3. 如果相等，则返回该中间元素的索引，并退出算法；此时就查找成功了。
4. 如果不相等，就再比较这两个元素的大小。
5. 如果该中间元素大于目标元素，那么就将当前序列的前半部分作为新的待查序列；这是因为后半部分的所有元素都大于目标元素，它们全都被排除了。
6. 如果该中间元素小于目标元素，那么就将当前序列的后半部分作为新的待查序列；这是因为前半部分的所有元素都小于目标元素，它们全都被排除了。
7. 在新的待查序列上重新开始第 1 步的工作。

二分查找之所以快速，是因为它在匹配不成功的时候，每次都能排除剩余元素中一半的元素。因此可能包含目标元素的有效范围就收缩得很快，而不像顺序查找那样，每次仅能排除一个元素。

问题：使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方

解法: 通过二分查找的手段，以双指针方式对头和尾元素做比较，以此判别无序点位置

```
var findIndex = (arr) => {
    let low = 0;
    let high = arr.length - 1;
    while(low <= high){
        let middle = low + ((high - low) >> 1);
        if( arr[middle] <= arr[0] || arr[middle] >= arr[high]) {
            return middle;
        }else if(arr[middle] > arr[0]) {
            middle = low + 1;// 向左偏移;
        }else {
            high = middle - 1;
        }
    }
    return -1;
}
```
